## 定义

区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。

令状态 $f(i,j)$ 表示将下标位置 $i$ 到 $j$ 的所有元素合并能获得的价值的最大值，那么 $f(i,j)=\max\{f(i,k)+f(k+1,j)+cost\}$，$cost$ 为将这两组元素合并起来的代价。

## 性质

区间 DP 有以下特点：

**合并**：即将两个或多个部分进行整合，当然也可以反过来；

**特征**：能将问题分解为能两两合并的形式；

**求解**：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。

## 解释

### 例题

???+note "[「NOI1995」石子合并](https://loj.ac/problem/10147)"
    题目大意：在一个环上有 $n$ 个数 $a_1,a_2,\dots,a_n$，进行 $n-1$ 次合并操作，每次操作将相邻的两堆合并成一堆，能获得新的一堆中的石子数量的和的得分。你需要最大化你的得分。

???+note "解题思路"
    需要考虑不在环上，而在一条链上的情况。

    令 $f(i,j)$ 表示将区间 $[i,j]$ 内的所有石子合并到一起的最大得分。

    写出 **状态转移方程**：$f(i,j)=\max\{f(i,k)+f(k+1,j)+\sum_{t=i}^{j} a_t \}~(i\le k<j)$

    令 $sum_i$ 表示 $a$ 数组的前缀和，状态转移方程变形为 $f(i,j)=\max\{f(i,k)+f(k+1,j)+sum_j-sum_{i-1} \}$。

    **怎样进行状态转移**

    由于计算 $f(i,j)$ 的值时需要知道所有 $f(i,k)$ 和 $f(k+1,j)$ 的值，而这两个中包含的元素的数量都小于 $f(i,j)$，所以我们以 $len=j-i+1$ 作为 DP 的阶段。首先从小到大枚举 $len$，然后枚举 $i$ 的值，根据 $len$ 和 $i$ 用公式计算出 $j$ 的值，然后枚举 $k$，时间复杂度为 $O(n^3)$

    **怎样处理环**

    题目中石子围成一个环，而不是一条链，怎么办呢？

    **方法一**：由于石子围成一个环，我们可以枚举分开的位置，将这个环转化成一个链，由于要枚举 $n$ 次，最终的时间复杂度为 $O(n^4)$。

    **方法二**：我们将这条链延长两倍，变成 $2\times n$ 堆，其中第 $i$ 堆与第 $n+i$ 堆相同，用动态规划求解后，取 $f(1,n),f(2,n+1),\dots,f(n-1,2n-2)$ 中的最优值，即为最后的答案。时间复杂度 $O(n^3)$。

???+note "参考代码"

    === "C++"

        ```cpp
        for (len = 1; len <= n; len++)
        for (i = 1; i <= 2 * n - 1; i++) {
            int j = len + i - 1;
            for (k = i; k < j && k <= 2 * n - 1; k++)
            f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + sum[j] - sum[i - 1]);
        }
        ```

    === "Python"

        ```python
        for len in range(1, n + 1):
            for i in range(1, 2 * n):
                j = len + i - 1
                while k < j and k <= 2 * n - 1:
                    f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + sum[j] - sum[i - 1])
                    k += 1
        ```

???+note "最优游戏策略"
    **问题描述：** 有n堆硬币排成一行，它们的价值分别是v1,v2,...,vn，n为偶数；两人交替拿硬币，每次只能在剩下的硬币中，拿走第一堆或最后一堆硬币。如果你是先手，你能拿到的最大价值是多少？
    
    例如：{8, 15, 3, 7}，先手这样拿可以获胜：（1）先手拿7；（2）对手拿8；（3）先手拿15；（4）对手拿3，结束。先手拿到的最大价值是7 + 15 = 22。

???+note "解题思路"
    这一题不能用贪心法。比如在样例中，如果先手第一次拿8，那么对手接下来肯定拿15，先手失败。
    
    定义二维dp，dp\[i\]\[j\]表示从第i堆到j堆硬币区间内，先手能拿到的最大值。

    在硬币区间\[i,j\]，先手有两个选择：
    
    1）拿i。接着对手也有2个选择，拿i+1或j：拿i+1，剩下\[i+2,j\]；拿j,剩下\[i+1,j−1\]。在这2个选择中，对手必然选那个对先手不利的。
    
    2）拿j。接着对手也有2个选择，拿i或j−1拿i，剩下\[i+1,j−1\]；拿j−1,剩下\[i,j−2\]。
    
    得到dp转移方程：
    
    `dp[i][j]=Max(V[i]+min(dp[i+2][j],dp[i+1][j−1]),V[j]+min(dp[i+1][j−1],dp[i][j−2]))`
    
    `dp[i][j]=V[i] if j==i`
    
    `dp[i][j]=max(V[i],V[j]) if j==i+1`

???+note "[矩阵链乘法](http://poj.org/problem?id=1651)"
    给定一个数组P\[\]，其中p\[i−1\]×p\[i\]表示矩阵，输出最少的乘法次数，并输出此时的括号方案。
    
    例如p\[\] = {40, 20, 30, 10, 30}，它表示4个矩阵：40×20，20×30，30×10，10×30。4个矩阵相乘，当括号方案是(A(BC))D时，有最少乘法次数26000。

???+note "解题思路"
    这是一个典型的区间DP问题。设链乘的矩阵是AiAi+1…Aj，即区间\[i,j\]，那么按结合率，可以把它分成2个子区间\[i,k\]、\[k+1,j\]，分别链乘，有：
    
    AiAi+1…Aj=(Ai...Ak)(Ak+1...Aj)
    
    必定有一个k，使得乘法次数最少，记这个k为ki,j。并且记Ai,j为此时AiAi+1…Aj通过加括号后得到的一个最优方案，它被ki,j分开。
    
    那么子链AiAi+1…Ak的方案Ai,k、子链Ak+1Ak+2…Aj的方案Ak+1,j也都是最优括号子方案。
    
    这样就形成了递推关系：
    Ai,j=min{Ai,k+Ak+1,j+pi−1pkpj}
    
    用二维矩阵dp\[i\]\[j\]来表示Ai,j，得到转移方程为：
    
    `dp[i][j]={0,i=j mindp[i][k]+dp[k+1][j]+p[i−1]p[k]p[j], i ≤ k < j}`
    
    dp\[1\]\[n\]就是答案，即最少乘法次数。
    
    dp\[i\]\[j\]的编码实现，可以套用区间DP模板，遍历i、j、k，复杂度是O(n^3^)。
    
    区间DP常常可以用四边形不等式优化，但是这一题不行，因为它不符合四边形不等式优化所需要的单调性条件。

???+note "[String painter](http://acm.hdu.edu.cn/showproblem.php?pid=2476)"
    **题目描述：** 给定两个长度相等的字符串A、B，由小写字母组成。一次操作，允许把A中的一个连续子串（区间）都转换为某个字符（就像用刷子刷成一样的字符）。要把A转换为B，问最低操作数是多少?
    
    **输入：** 第一行是字符串A，第二行是字符串B。两个字符串的长度不大于100。
    
    **输出：** 一个表示答案的整数。
    
    输入样例：
    
    zzzzzfzzzzz
    
    abcdefedcba
    
    输出样例：
    
    6
    
    提示：第1次把zzzzzfzzzzz转换为aaaaaaaaaaa，第2次转为abbbbbbbbba，第3次转为abccccccccba...

???+note "解题思路"
    这道经典题，能帮助读者深入理解区间DP是如何构造和编码的。
    
    （1）从空白串转换到B
    先考虑简单一点的问题：从空白串转换到B。为方便阅读代码，把字符串存储为B\[1\]~B\[n\]，不从0开始，编码的时候这样输入：scanf("%s%s", A+1, B+1)。
    
    如何定义DP状态？可以定义dp\[i\]，表示在区间\[1,i\]内转换为B的最少步数。或者更进一步，定义dp\[i\]\[j\]，表示在区间\[i,j\]内从空白串转换到B时的最少步数。重点是区间\[i,j\]两端的字符B\[i\] 和B\[j\]，分析以下两种情况。
    
    1）若B\[i\] = B\[j\]。第一次刷用B\[i\]把区间\[i,j\]刷一遍，这个刷法肯定是最优的。如果分别去掉两个端点，得到2个区间\[i+1,j\]、\[i,j−1\]，这2个区间的最小步数相等，也等于原区间\[i,j\]的最小步数。例如B\[i,j\]="abbba"，先用"a"全部刷一遍，再刷1次"bbb"，共刷2次。如果去掉第一个"a"，剩下的"bbba"，也是刷2次。
    
    2）若B\[i\] ≠ B\[j\]。因为两端点不等，至少要各刷1次。用标准的区间操作，把区间分成\[i,k\]和\[k+1,j\]两部分，枚举最小步数。
    
    （2）从A转换到B
    
    如何求dp\[1\]\[j\]？观察A和B相同位置的字符，分析以下两种情况.
    
    1）若A\[j\] = B\[j\]。这个字符不用转换，有dp\[1\]\[j\] = dp\[1\]\[j−1\]。
    
    2）若A\[j\] ≠ B\[j\]。仍然用标准的区间DP，把区间分成\[1,k\]和\[k+1,j\]两部分，枚举最小步数。这里利用了上一步从空白转换到B的结果，当区间\[k+1,j\]内A和B的字符不同时，从A转到B，与从空白串转换到B是等价的。

???+note "参考代码"

    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    char A[105],B[105];
    int dp[105][105];
    const int INF = 0x3f3f3f3f;
    int main() {
        while(~scanf("%s%s", A+1, B+1)){             //输入A, B
            int n = strlen(A+1);
                for(int i=1;i<=n;i++)  
                dp[i][i]=1;                          //初始化
                        //先从空白串转换到B
                for(int len=2; len<=n; len++)
                    for(int i=1; i<=n-len+1; i++){
                    int j = i + len-1;
                    dp[i][j] = INF;
                                        if(B[i] == B[j])//区间[i, j]两端的字符相同B[i] = B[j]
                        dp[i][j] = dp[i+1][j];  //或者 = dp[i][j-1])
                                        else    //区间[i, j]两端的字符不同B[i] ≠ B[j]
                                for(int k=i; k<j; k++)
                                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]);                
                    }
                        //下面从A转换到B
            for(int j=1; j<=n; ++j){
                if(A[j] == B[j])  
                        dp[1][j] = dp[1][j-1];            //字符相同不用转
                else 
                    for(int k=1; k<j; ++k)
                    dp[1][j] = min(dp[1][j], dp[1][k] + dp[k+1][j]);
            }
            printf("%d\n",dp[1][n]);
        }
        return 0;
    }
    ```

???+note "[You Are the One](http://acm.hdu.edu.cn/showproblem.php?pid=4283)"
    **题目描述：** n个男孩去相亲，排成一队上场。大家都不想等，排队越靠后越愤怒。每人的耐心不同，用D表示火气，设男孩i的火气是Di，他排在第k个时，愤怒值是(k−1)\∗Di。
    
    导演不想看到会场气氛紧张。他安排了一个黑屋，可以调整这排男孩上场的顺序，屋子很狭长，先进去的男孩最后出来（黑屋就是一个堆栈）。例如，当男孩A排到时，如果他后面的男孩B火气更大，就把A送进黑屋，让B先上场。一般情况下，那些火气小的男孩要多等等，让火气大的占便宜。不过，零脾气的你也不一定吃亏，如果你原本排在倒数第二个，而最后一个男孩脾气最坏，导演为了让这个刺头第一个上场，把其他人全赶进了黑屋，结果你就排在了黑屋的第1名，第二个上场相亲了。
    
    注意，每个男孩都要进出黑屋。
    
    对所有男孩的愤怒值求和，求所有可能情况的最小和。
    
    **输入：** 第一行包含一个整数T，即测试用例的数量。对于每种情况，第一行是n（0 < n <= 100），后面n行，整数D1-Dn表示男孩的火气值（0 <= Di <= 100）。
    
    **输出：** 对每个用例，输出最小愤怒值之和。

???+note "解题思路"
    读者可以试试用栈来模拟，非常困难。这是一道区间DP，巧妙地利用了栈的特性。
    
    定义dp\[i\]\[j\]，表示从第i个人到第j个人，即区间\[i,j\]的最小愤怒值之和。
    
    由于栈的存在，这一题的区间\[i,j\]的分割点k比较特殊。分割时，总是用区间\[i,j\]的第一个元素i把区间分成两部分，让i第k个从黑屋出来上场相亲，即第k个出栈。根据栈的特性：若第一个元素i第k个出栈，则第二到k−1个元素肯定在第一个元素之前出栈，第k+1到最后一个元素肯定在第k个之后出栈。
    
    例如，5个人排队序号是1、2、3、4、5。如果要第1（i=1）个人第3（k=3）个出场，那么栈的操作是这样：1进栈、2进栈、3进栈、3出栈、2出栈，1出栈。2号、3号在1号之前出栈，1号第3个出栈，4号5号在1号后面出栈。
    
    分割点k（1 ≤ k ≤ j-i+1）把区间划分成了两段，即dp\[i+1\]\[i+k−1\]和dp\[i+k\]\[j\]。dp\[i\]\[j\]的计算分为三部分：
    
    （1）dp\[i+1\]\[i+k−1\]。原来i后面的k−1个人，现在排到i前面了。
    
    （2）第i个人往后挪了k−1个位置，愤怒值加上D\[i\]\*(k−1)。
    
    （3）dp\[i+k\]\[j\] + k∗(sum\[j\]−sum\[i+k−1\])。第k个位置后面的人，即区间\[i+k,j\]的人，由于都在前k个人之后，相当于从区间的第1个位置往后挪了k个位置，所以整体愤怒值要加上k∗(sum\[j\]−sum\[i+k−1\])。其中sum\[j\]=∑ji=1Di，是1~j所有人D值的和，sum\[j\]−sum\[i+k−1\]是区间\[i+k,j\]内这些人的D值和。

???+note "参考代码"
    代码完全套用“石子合并”的模板。其中DP方程给出了两种写法，对照看更清晰。

    ```cpp
    for(int len=2; len<=n; len++)
        for(i=1;i<=n-len+1;i++) {
            j = len + i - 1;
            dp[i][j] = INF; 
            for(int k=1;k<=j-i+1;k++)       //k：i往后挪了k位。这样写容易理解
                dp[i][j] = min(dp[i][j], dp[i+1][i+k-1] + D[i]*(k-1)
                                    + dp[i+k][j] + k*(sum[j]-sum[i+k-1]));   //DP方程
        //for(int k=i;k<=j;k++)           //或者这样写。k是整个队伍的绝对位置
        //    dp[i][j] = min(dp[i][j], dp[i+1][k] + D[i]*(k-i)
                                    + dp[k+1][j] + (k-i+1)*(sum[j]-sum[k]));
    }
    ```

## 二维区间DP

前面的例子的区间\[i,j\]可以看成在一条直线上移动，即一维DP。这里给出一个二维区间DP的例题，它的区间同时在两个方向移动。

???+note "[Rectangle Painting](https://vjudge.net/problem/CodeForces-1199F)"
    **题目描述：**  有一个n×n大小的方格图，某些方格初始是黑色，其余为白色。一次操作，可以选定一个h×w的矩形，把其中所有方格涂成白色，代价是max(h, w)。要求用最小的代价把所有方格变成白色。
    
    **输入：** 第1行是整数n，表示方格的大小。后面有n行，每行长度为n的串，包含符号'.'和'#'，'.'表示白色，'#'表示黑色。第i行的第j个字符是(i, j)。n ≤ 50。
    
    **输出：** 打印一个整数，表示把所有方格涂成白色的最小代价。
    
    输入样例：
    
    5
    
    #...#
    
    .#.#.
    
    .....
    
    .#...
    
    #....
    
    输出样例：
    
    5

???+note "解题思路"
    设矩形区域从左下角坐标(x1,y1)到右上角坐标(x2,y2)。定义状态dp\[x1\]\[y1\]\[x2\]\[y2\]，表示把这个区域内染成白色的最小代价。
    
    这个区域可以分别按x轴或者按y轴分割成两个矩形，遍历所有可能的分割，求最小代价。那么从x方向看，就是一个区间DP；从y方向看，也是区间DP。
    
    代码可以完全套用前面一维DP的模板，分别在两个方向操作。
    
    （1）x方向，区间分为\[x1,k\]和\[k+1,x2\]。状态转移方程是：
    
    `dp[x1][][x2][] = min(dp[x1][][x2][], dp[x1][][k][] + dp[k+1][][x2][])`
    
    （2）y方向，区间分为\[y1,k\]和\[k+1,y2\]。状态转移方程是：
    
    `dp[][y1][][y2] = min(dp[][y1][][y2], dp[][y1][][k] + dp[][k+1][][y2])`

???+note "参考代码"
    下面的代码有5层循环，时间复杂度O(n^5^)。对比一维区间DP，有3层循环，复杂度是O(n^3^)。

    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    #define N 55
    int dp[N][N][N][N];
    char mp[N][N];       //方格图
    int main(){
        int n;  cin>>n;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                cin>>mp[i][j];
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(mp[i][j]=='.')  dp[i][j][i][j]=0;  //白格不用涂
                else dp[i][j][i][j]=1;                //黑格(i,j)涂成白色需1次
            
        for(int lenx=1;lenx<=n;lenx++)        //len从1开始，不是2。因为有x和y两个方向
            for(int leny=1;leny<=n;leny++)    
                for(int x1=1;x1<=n-lenx+1;x1++)
                    for(int y1=1;y1<=n-leny+1;y1++){					
                        int x2 = x1+lenx-1;             //x1：x轴起点；x2：x轴终点
                        int y2 = y1+leny-1;             //y1：y轴起点；y2：y轴终点
                        if(x1==x2 && y1==y2) continue;  //lenx=1且leny=1的情况
                        
                        dp[x1][y1][x2][y2] = max(abs(x1-x2),abs(y1-y2)) + 1;  //初始值 
                        
                        for(int k=x1;k<x2;k++)   //枚举x方向，y不变。区间[x1,k]+[k+1,x2]
                            dp[x1][y1][x2][y2] = min(dp[x1][y1][x2][y2],
                                                    dp[x1][y1][k][y2]+dp[k+1][y1][x2][y2]);
                            
                        for(int k=y1;k<y2;k++)   //枚举y方向，x不变。区间[y1,k]+[k+1,y2]
                            dp[x1][y1][x2][y2] = min(dp[x1][y1][x2][y2],
                                                    dp[x1][y1][x2][k]+dp[x1][k+1][x2][y2]);
                    
                    }
        
        cout << dp[1][1][n][n];
    }
    ```

## 几道练习题

- [Cheapest Palindrome](http://poj.org/problem?id=3280)
- [Leetcode](https://leetcode-cn.com/circle/article/NfHhXD/)
- [Vjudge练习](https://vjudge.net/contest/77874#overview)
- [棋盘分割](http://poj.org/problem?id=1191)
- [NOIP 2006 能量项链](https://vijos.org/p/1312)
- [NOIP 2007 矩阵取数游戏](https://vijos.org/p/1378)
- [「IOI2000」邮局](https://www.luogu.com.cn/problem/P4767)
- [切木棍](https://vjudge.net/problem/UVA-10003)
- [括号序列](https://vjudge.net/problem/UVA-1626)
- [最大面积最小的三角划分](https://vjudge.net/problem/UVA-1331)
